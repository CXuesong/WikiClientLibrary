using System.Collections.ObjectModel;
using System.Text.Json;
using System.Text.Json.Serialization;
using WikiClientLibrary.Infrastructures;
using WikiClientLibrary.Pages.Queries.Properties;
using WikiClientLibrary.Sites;

namespace WikiClientLibrary.Pages.Parsing;

/// <summary>
/// Contains parsed content of specific page or wikitext.
/// </summary>
/// <remarks>Use <see cref="WikiSiteExtensions.ParsePageAsync(WikiSite,string)"/> or other related methods to get parsed content.</remarks>
[JsonContract]
public sealed class ParsedContentInfo
{

    /// <summary>
    /// The title of the page.
    /// </summary>
    public string Title { get; init; }

    /// <summary>
    /// The displayed title HTML.
    /// </summary>
    /// <remarks>The actual displayed title can be reformatted by DISPLAYTITLE magic word, and language variant conversions may be applied.</remarks>
    public string DisplayTitle { get; init; }

    public long PageId { get; init; }

    [JsonPropertyName("revid")]
    public long RevisionId { get; init; }

    /// <summary>
    /// Parsed content, in HTML form.
    /// </summary>
    [JsonIgnore]
    public string Content { get; init; }

    /// <summary>
    /// Parsed summary, if exists, in HTML form.
    /// </summary>
    [JsonIgnore]
    public string Summary { get; init; }

    [JsonInclude]
    [JsonPropertyName("text")]
    private BoxedStringValue DummyText
    {
        init => Content = value.Star;
    }

    [JsonInclude]
    [JsonPropertyName("parsedsummary")]
    private BoxedStringValue DummySummary
    {
        init => Summary = value.Star;
    }

    [JsonPropertyName("langlinks")]
    public IReadOnlyCollection<LanguageLinkInfo> LanguageLinks { get; init; }

    public IReadOnlyCollection<ContentCategoryInfo> Categories { get; init; }

    public IReadOnlyList<ContentSectionInfo> Sections { get; init; }

    public IReadOnlyCollection<ContentPropertyInfo> Properties { get; init; }

    /// <summary>
    /// Gets a list of templates transcluded in this page.
    /// Available if <see cref="ParsingOptions.TranscludedPages"/> is specified.
    /// </summary>
    [JsonPropertyName("templates")]
    public IReadOnlyCollection<ContentTransclusionInfo> TranscludedPages { get; init; }

    /// <summary>
    /// Gets the limit reports generated by the parser.
    /// Available if <see cref="ParsingOptions.LimitReport"/> is specified.
    /// </summary>
    [JsonPropertyName("limitreportdata")]
    public IReadOnlyCollection<ParserLimitReport> ParserLimitReports { get; init; }

    /// <summary>
    /// Determines the redirects that has been followed to reach the page.
    /// </summary>
    public IReadOnlyCollection<ContentRedirectInfo> Redirects { get; init; }

    private sealed class BoxedStringValue
    {

        [JsonPropertyName("*")]
        public required string Star { get; init; }

    }

}

[JsonContract]
public sealed class ContentRedirectInfo
{

    public string From { get; init; }

    public string To { get; init; }

}

[JsonContract]
public sealed class ContentPropertyInfo
{

    public required string Name { get; init; }

    [JsonPropertyName("*")]
    public required JsonElement Value { get; init; }

    public T? GetValueAs<T>() => WikiJsonElementHelper.ConvertTo<T>(Value);

    /// <inheritdoc />
    public override string ToString() => Name + "=" + Value;

}

[JsonContract]
public sealed class ContentSectionInfo
{

    /// <summary>
    /// Index of the section.
    /// </summary>
    /// <remarks>
    /// This value is usually a number.
    /// For titles in transcluded templates, this property may have a value like "T-1", "T-2", etc.
    /// </remarks>
    /// <seealso cref="WikiPage.EditSectionAsync"/>
    public required string Index { get; init; }

    /// <summary>
    /// Heading text.
    /// </summary>
    [JsonPropertyName("line")]
    public required string Heading { get; init; }

    /// <summary>
    /// Anchor name of the heading.
    /// </summary>
    public required string Anchor { get; init; }

    /// <summary>
    /// Heading number. E.g. 3.2 .
    /// </summary>
    public required string Number { get; init; }

    /// <summary>
    /// Level of the heading.
    /// </summary>
    public int Level { get; init; }

    /// <summary>
    /// Toc level of the heading. This is usually <see cref="Level"/> - 1.
    /// </summary>
    public int TocLevel { get; init; }

    /// <summary>
    /// Title of the page.
    /// </summary>
    [JsonPropertyName("fromtitle")]
    public string? PageTitle { get; init; }

    /// <summary>
    /// Byte offset of the section.
    /// </summary>
    /// <remarks>
    /// Note that sometimes this property is not available,
    /// especially when the heading is included in a template.
    /// </remarks>
    public int? ByteOffset { get; init; }

    /// <summary>
    /// 返回表示当前对象的字符串。
    /// </summary>
    /// <returns>
    /// 表示当前对象的字符串。
    /// </returns>
    public override string ToString()
    {
        return PageTitle + "#" + Heading;
    }

}

[JsonContract]
public sealed class ContentCategoryInfo
{

    /// <summary>
    /// Title of the category.
    /// </summary>
    [JsonPropertyName("*")]
    public string CategoryName { get; init; }

    public string SortKey { get; init; }

    public bool IsHidden { get; init; }

    /// <inheritdoc />
    public override string ToString()
        => string.IsNullOrEmpty(SortKey) ? CategoryName : (CategoryName + "|" + SortKey);

}

/// <summary>
/// Represents a transcluded page/template/module in the parsed page.
/// </summary>
[JsonContract]
public sealed class ContentTransclusionInfo
{

    /// <summary>
    /// Title of the transcluded page.
    /// </summary>
    [JsonPropertyName("*")]
    public string Title { get; init; }

    /// <summary>
    /// Namespace id of the transcluded page.
    /// </summary>
    [JsonPropertyName("ns")]
    public int NamespaceId { get; init; }

    /// <summary>
    /// Whether the transcluded page exists.
    /// </summary>
    public bool Exists { get; init; }

    /// <inheritdoc />
    public override string ToString() => Title;

}

/// <summary>
/// Represents a group in the limit report generated by parser.
/// </summary>
[JsonContract]
public sealed class ParserLimitReport
{

    /// <summary>
    /// Limit report name.
    /// </summary>
    /// <remarks>E.g. smw-limitreport-intext-parsertime, limitreport-templateargumentsize .</remarks>
    public string Name { get; init; }

    /// <summary>
    /// Current value of the report, if available.
    /// </summary>
    [JsonIgnore]
    public double? Value => TryGetDoubleValue("0");

    /// <summary>
    /// Value limit of the report, if available.
    /// </summary>
    [JsonIgnore]
    public double? Limit => TryGetDoubleValue("1");

    private double? TryGetDoubleValue(string key)
    {
        if (extensionDataRaw == null) return null;
        if (!extensionDataRaw.TryGetValue(key, out var e)) return null;
        if (WikiJsonElementHelper.TryConvertToDouble(e, out double d)) return d;
        return null;
    }

    private ReadOnlyDictionary<string, JsonElement>? extensionDataWrapper;

    /// <summary>
    /// All the content of the report.
    /// </summary>
    [JsonExtensionData] [JsonInclude] private Dictionary<string, JsonElement>? extensionDataRaw;

    [JsonIgnore]
    public IReadOnlyDictionary<string, JsonElement> Content
    {
        get
        {
            var wrapper = this.extensionDataWrapper;
            if (wrapper != null) return wrapper;
            wrapper = extensionDataRaw == null ? emptyContent : new ReadOnlyDictionary<string, JsonElement>(extensionDataRaw);
            var prev = Interlocked.CompareExchange(ref extensionDataWrapper, wrapper, null);
            if (prev != null) wrapper = prev;
            return wrapper;
        }
    }

    private static readonly ReadOnlyDictionary<string, JsonElement> emptyContent = new(new Dictionary<string, JsonElement>(0));

    /// <inheritdoc />
    public override string ToString()
    {
        var s = Name + ": " + Value;
        if (Limit != null) s += "/" + Limit;
        return s;
    }

}
